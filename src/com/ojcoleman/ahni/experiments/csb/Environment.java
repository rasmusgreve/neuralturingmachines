package com.ojcoleman.ahni.experiments.csb;

import java.awt.Graphics2D;
import java.util.Random;

import org.apache.commons.math3.linear.ArrayRealVector;
import org.jgapcustomised.Chromosome;

import com.ojcoleman.ahni.evaluation.novelty.Behaviour;
import com.ojcoleman.ahni.evaluation.novelty.NoveltySearch;
import com.ojcoleman.ahni.hyperneat.Configurable;
import com.ojcoleman.ahni.hyperneat.Properties;
import com.ojcoleman.ahni.util.ArrayUtil;

public abstract class Environment implements Configurable {
	Properties props;
	/**
	 * The containing RLContinuousStateBased object.
	 */
	protected RLContinuousStateBased rlcsb;
	protected int size;
	protected int id;
	protected ArrayRealVector startState;
	protected ArrayRealVector goalState;

	@Override
	public void init(Properties props) {
		this.props = props;
		size = props.getIntProperty(RLContinuousStateBased.SIZE);
	}

	/**
	 * Set-up the environment configuration.
	 */
	public abstract void setUp(int id);

	/**
	 * Returns the output size of the environment including the reinforcement signal, this is generally input directly
	 * to the agent, thus the agent input vector size would usually be equal to this.
	 */
	public abstract int getOutputSize();

	/**
	 * Returns the input size of the environment, the output of the agent is generally input directly to the
	 * environment, thus the agent output vector size would usually be equal to this.
	 */
	public abstract int getInputSize();

	/**
	 * This function should do three things: (1) update the given state given the input; (2) update the given state
	 * internally if the environment is dynamic (changes even when if the agent provides no "actions"), and (3)
	 * update/set the output based on the new current state.
	 * @return the performance value associated with the new environment state, must be in the range [0, 1].
	 */
	public abstract double updateStateAndOutput(ArrayRealVector state, double[] input, double[] output);

	/**
	 * Update/set the output based on the given state.
	 * @return the performance value associated with the given environment state, must be in the range [0, 1].
	 */
	public abstract double getOutputForState(ArrayRealVector state, double[] output);

	/**
	 * @return the reward value associated with the given environment state, must be in the range [0, 1].
	 */
	public abstract double getRewardForState(ArrayRealVector state);

	/**
	 * @return the performance value associated with the given environment state, must be in the range [0, 1].
	 */
	public abstract double getPerformanceForState(ArrayRealVector state);

	/**
	 * Return the minimum required steps to solve this environment instance.
	 */
	public abstract int getMinimumStepsToSolve();
	
	/**
	 * Set the minimum required steps to solve this environment instance (generally only for internal use).
	 */
	public abstract void setMinimumStepsToSolve(int steps);

	/**
	 * Return true iff it is possible to (further) increase the difficulty of environments of this type, eg by
	 * introducing a larger number of obstacles, a more convoluted transform between state and output, etc.
	 */
	public abstract boolean increaseDifficultyPossible();

	/**
	 * Adjust the variables determining difficulty to increase the difficulty of environment instances generated by this
	 * environment type. The {@link #setUp(int)} method will be called immediately after calling this method to generate
	 * a new environment instance.
	 */
	public abstract void increaseDifficulty();

	/**
	 * Optionally allow rendering (some aspect) of the environment configuration to an image. The image is used to track the progress of
	 * the agent through the environment. This method is called for every trial and is only called if the environment
	 * size is 2 (thus allowing showing the current state as a point on a 2D plane). An example implementation may
	 * render parts of the state space that are inaccessible.
	 * 
	 * @param g The graphics object to render on.
	 * @param imageSize The size of the image (width and height).
	 */
	public void logToImageForTrial(Graphics2D g, int imageSize) {
		
	}

	/**
	 * Optionally allow rendering the environment configuration to an image or images. This method is called once for a
	 * set of trials. Implementations must handle creating the images and saving them to disk.
	 * 
	 * @param baseFileName The directory and base file name to use for the images saved to disk.
	 * @param imageSize The (suggested) image size. 
	 */
	public void logToImage(String baseFileName, int imageSize) {
	}
	
	@Override
	public String toString() {
		return "ID: " + id + ". Start and goal states: " + startState + " => " + goalState;
	}
}