package com.anji_ahni.neat;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import org.apache.log4j.Logger;
import org.jgapcustomised.Chromosome;
import org.jgapcustomised.ChromosomeMaterial;
import org.jgapcustomised.Configuration;
import org.jgapcustomised.Genotype;
import org.jgapcustomised.InvalidConfigurationException;
import org.jgapcustomised.MutationOperator;

import com.anji_ahni.util.Properties;
import com.ojcoleman.ahni.hyperneat.HyperNEATEvolver;

/**
 * Modifies JGAP Genotype to allow more flexibility in how initial population is generated.
 * 
 * @author Oliver Coleman
 */
public class NEATGenotype extends Genotype {
	private static Logger logger = Logger.getLogger(NEATGenotype.class);
	
	public NEATGenotype(Properties props, Configuration a_activeConfiguration, List<Chromosome> a_initialChromosomes) throws InvalidConfigurationException {
		super(props, a_activeConfiguration, a_initialChromosomes);
	}

	/**
	 * Convenience method that returns a newly constructed NEATGenotype instance configured according to the given
	 * Configuration instance. The population of Chromosomes will created according to the setup of the sample
	 * Chromosome in the Configuration object, but the gene values (alleles) will be set to random legal values.
	 * <p>
	 * Note that the given Configuration instance must be in a valid state at the time this method is invoked, or an
	 * InvalidConfigurationException will be thrown.
	 * 
	 * @param a_activeConfiguration
	 * @return A newly constructed NEATGenotype instance.
	 * @throws InvalidConfigurationException if the given Configuration instance not in a valid state.
	 */
	public static NEATGenotype randomInitialGenotype(Properties props, NeatConfiguration a_activeConfiguration) throws InvalidConfigurationException {
		if (a_activeConfiguration == null) {
			throw new IllegalArgumentException("The Configuration instance may not be null.");
		}

		a_activeConfiguration.lockSettings();

		// Create an array of chromosomes equal to the desired size in the
		// active Configuration and then populate that array with Chromosome
		// instances constructed according to the setup in the sample
		// Chromosome, but with random gene values (alleles). The Chromosome
		// class' randomInitialChromosome() method will take care of that for
		// us.
		// ------------------------------------------------------------------
		int populationSize = a_activeConfiguration.getPopulationSize();
		List<Chromosome> chroms = new ArrayList<Chromosome>(populationSize);
		
		HashMap<MutationOperator, Double> origMutatationRates = new HashMap<MutationOperator, Double>();
		double mutRateFactor = 0;
		if (!props.getBooleanProperty(NeatConfiguration.INITIAL_TOPOLOGY_FULLY_CONNECTED_KEY, true)) {
			logger.info("Generating initial population with random structure generated by mutation operators:");
			
			mutRateFactor = props.getDoubleProperty(NeatConfiguration.INITIAL_TOPOLOGY_MUTATION_FACTOR_KEY, 0);
			if (mutRateFactor > 1) {
				logger.info("\tTemporary mutation rates are:");
				// Temporarily increase mutation rates to create varied initial population. 
				for (MutationOperator operator : a_activeConfiguration.getMutationOperators()) {
					origMutatationRates.put(operator, operator.getMutationRate());
					operator.setMutationRate(operator.getMutationRate() * mutRateFactor);
					logger.info("\t\t" + operator.getClass().getSimpleName() + ": " + operator.getMutationRate());
				}
			}
		}
		
		ChromosomeMaterial sample = a_activeConfiguration.getSampleChromosomeMaterial();
		
		// Add the sample chromosome unchanged, in case it's a seed provided by the user rather than randomly generated.
		chroms.add(new Chromosome(sample.clone(null), a_activeConfiguration.nextChromosomeId(), a_activeConfiguration.getObjectiveCount(), a_activeConfiguration.getNoveltyObjectiveCount()));
		
		double avgAddedGenes = 0;
		for (int i = 1; i < populationSize; i++) {
			ChromosomeMaterial material = null;
			// If the sample network is already fully connected don't add additional structure.
			if (props.getBooleanProperty(NeatConfiguration.INITIAL_TOPOLOGY_FULLY_CONNECTED_KEY, true)) {
				material = ChromosomeMaterial.randomInitialChromosomeMaterial(a_activeConfiguration);
			}
			else {
				material = sample.clone(null);
				for (MutationOperator operator : a_activeConfiguration.getMutationOperators()) {
					operator.mutate(a_activeConfiguration, material);
				}
				avgAddedGenes += material.size() - sample.size();
			}
			
			chroms.add(new Chromosome(material, a_activeConfiguration.nextChromosomeId(), a_activeConfiguration.getObjectiveCount(), a_activeConfiguration.getNoveltyObjectiveCount()));
		}
		
		if (!props.getBooleanProperty(NeatConfiguration.INITIAL_TOPOLOGY_FULLY_CONNECTED_KEY, true)) {
			logger.info("\tAdded " + (avgAddedGenes / populationSize) + " extra genes on average.");
			if (mutRateFactor > 1) {
				// Restore original mutation rates.
				for (MutationOperator operator : a_activeConfiguration.getMutationOperators()) {
					operator.setMutationRate(origMutatationRates.get(operator));
				}
			}
		}
		
		return new NEATGenotype(props, a_activeConfiguration, chroms);
	}
}
